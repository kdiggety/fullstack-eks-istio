name: Deploy Local K8s (Umbrella Helm)

on:
  push:
    branches: [ main ]          # auto-trigger on merges/pushes to main
  workflow_dispatch:            # allow manual runs from Actions UI/CLI

permissions:
  contents: read
  packages: read

jobs:
  deploy:
    runs-on: [self-hosted, local-k8s]

    permissions:
      contents: read
      packages: read

    env:
      NAMESPACE: sample
      OWNER: ${{ github.repository_owner }}
      REPO:  ${{ github.event.repository.name }}
      WEB_IMAGE: ghcr.io/${{ github.repository_owner }}/web
      API_IMAGE: ghcr.io/${{ github.repository_owner }}/api

      # Optional: if images are private and you want docker pulls to use a secret
      GHCR_USERNAME: ${{ secrets.GHCR_USERNAME }}
      GHCR_TOKEN: ${{ secrets.GHCR_TOKEN }}
      PULL_SECRET_NAME: ghcr-pull

      # Let gh CLI use the workflow token (has packages:read due to permissions above)
      GH_TOKEN: ${{ github.token }}

      # If your GHCR packages live under an ORG, set:
      #   GH_PACKAGES_SCOPE: org
      #   GH_PACKAGES_OWNER: your-org-name
      GH_PACKAGES_SCOPE: user
      GH_PACKAGES_OWNER: ${{ github.repository_owner }}

    steps:
      - name: Checkout (clean)
        uses: actions/checkout@v4
        with:
          clean: true
          fetch-depth: 0

      - name: Check prerequisites (gh, jq, buildx)
        shell: bash
        run: |
          set -euo pipefail
          command -v gh >/dev/null 2>&1 || { echo "::error ::gh CLI not found on runner"; exit 1; }
          command -v jq >/dev/null 2>&1 || { echo "::error ::jq not found on runner"; exit 1; }
          docker buildx version >/dev/null 2>&1 || { echo "::error ::docker buildx not available"; exit 1; }
          echo "Prereqs OK"

      - name: Ensure kubectl context & namespace
        shell: bash
        run: |
          set -euo pipefail
          kubectl config current-context
          kubectl get nodes -o wide
          kubectl get ns "$NAMESPACE" >/dev/null 2>&1 || kubectl create ns "$NAMESPACE"
          kubectl label ns "$NAMESPACE" istio-injection=enabled --overwrite

      - name: Login to GHCR for pulls (optional)
        if: ${{ env.GHCR_USERNAME != '' && env.GHCR_TOKEN != '' }}
        uses: docker/login-action@v3
        with:
          registry: ghcr.io
          username: ${{ env.GHCR_USERNAME }}
          password: ${{ env.GHCR_TOKEN }}

      - name: Ensure imagePullSecret on default SA (optional)
        if: ${{ env.GHCR_USERNAME != '' && env.GHCR_TOKEN != '' }}
        shell: bash
        run: |
          set -euo pipefail
          kubectl -n "$NAMESPACE" delete secret "$PULL_SECRET_NAME" --ignore-not-found
          kubectl -n "$NAMESPACE" create secret docker-registry "$PULL_SECRET_NAME" \
            --docker-server=ghcr.io \
            --docker-username="$GHCR_USERNAME" \
            --docker-password="$GHCR_TOKEN"
          kubectl -n "$NAMESPACE" patch serviceaccount default \
            --type merge \
            -p "{\"imagePullSecrets\":[{\"name\":\"${PULL_SECRET_NAME}\"}]}"

      - name: Helm repos & deps (umbrella chart)
        shell: bash
        run: |
          set -euo pipefail
          helm repo add bitnami https://charts.bitnami.com/bitnami
          helm repo update
          pushd ./helm/chart >/dev/null
          rm -rf charts
          helm dependency update .
          helm dependency build .
          ls -l charts || true
          popd >/dev/null

      - name: Show currently deployed images (before)
        shell: bash
        run: |
          set -euo pipefail
          echo "Web (before):"
          kubectl -n "$NAMESPACE" get deploy web -o jsonpath='{.spec.template.spec.containers[?(@.name=="web")].image}{"\n"}' || true
          echo "API (before):"
          kubectl -n "$NAMESPACE" get deploy api -o jsonpath='{.spec.template.spec.containers[?(@.name=="api")].image}{"\n"}' || true

      # ---------- Resolve LATEST TAGS INDEPENDENTLY (web & api) ----------
      - name: Resolve latest tags for web and api (independent)
        id: tags
        shell: bash
        run: |
          set -euo pipefail

          have_img() {
            docker buildx imagetools inspect "$1:$2" >/dev/null 2>&1
          }

          gh_pkg_url() {
            local pkg="$1"
            if [ "${GH_PACKAGES_SCOPE:-user}" = "org" ]; then
              echo "/orgs/${GH_PACKAGES_OWNER}/packages/container/${pkg}/versions?per_page=200"
            else
              echo "/users/${GH_PACKAGES_OWNER}/packages/container/${pkg}/versions?per_page=200"
            fi
          }

          # Ordered tag candidates: prefer 40-hex SHA tags first (immutable), then others; newest first by version.updated_at
          list_tags () {
            local pkg="$1"
            local url; url="$(gh_pkg_url "$pkg")"
            gh api -H "Accept: application/vnd.github+json" "$url" \
            | jq -r '
                [ .[] as $v
                  | ($v.metadata.container.tags // [])
                  | map(select(. != "latest" and . != "dev"))
                  | map({updated_at: $v.updated_at, tag: .})
                ] | add
                | ( [ .[] | select(.tag | test("^[0-9a-f]{40}$")) ] | sort_by(.updated_at) | reverse | .[]?.tag ),
                  ( [ .[] | select(.tag | test("^[0-9a-f]{40}$") | not) ] | sort_by(.updated_at) | reverse | .[]?.tag )
              '
          }

          echo "Resolving latest commit SHA on main…"
          LATEST_SHA=$(gh api -H "Accept: application/vnd.github+json" "/repos/$OWNER/$REPO/commits/main" -q .sha)
          echo "Latest main SHA: $LATEST_SHA"

          resolve_for() {
            local image="$1" pkg="$2"
            local chosen=""
            # First: try the current main SHA
            if have_img "$image" "$LATEST_SHA"; then
              echo "$LATEST_SHA"
              return 0
            fi
            # Else: iterate ordered candidates (newest first)
            while IFS= read -r t; do
              [ -z "$t" ] && continue
              if have_img "$image" "$t"; then chosen="$t"; break; fi
            done < <(list_tags "$pkg" || true)

            if [ -z "$chosen" ]; then
              echo "::error ::$pkg: Could not resolve a usable tag (need packages:read? are tags present?)"
              exit 1
            fi
            echo "$chosen"
          }

          WEB_TAG="$(resolve_for "$WEB_IMAGE" web)"
          API_TAG="$(resolve_for "$API_IMAGE" api)"

          echo "Resolved tags:"
          echo "  web: $WEB_TAG"
          echo "  api: $API_TAG"
          echo "WEB_TAG=$WEB_TAG" >> "$GITHUB_OUTPUT"
          echo "API_TAG=$API_TAG" >> "$GITHUB_OUTPUT"

      - name: Decide pull policies & mutate flags
        id: mutate
        shell: bash
        env:
          WEB_TAG: ${{ steps.tags.outputs.WEB_TAG }}
          API_TAG: ${{ steps.tags.outputs.API_TAG }}
        run: |
          set -euo pipefail
          is_mutable() {
            case "$1" in
              dev|latest) return 0 ;;
              *) return 1 ;;
            esac
          }

          WEB_PULL=IfNotPresent
          API_PULL=IfNotPresent
          WEB_FORCE_RESTART=false
          API_FORCE_RESTART=false

          if is_mutable "$WEB_TAG"; then
            WEB_PULL=Always
            WEB_FORCE_RESTART=true
          fi
          if is_mutable "$API_TAG"; then
            API_PULL=Always
            API_FORCE_RESTART=true
          fi

          echo "WEB_PULL=$WEB_PULL" >> "$GITHUB_OUTPUT"
          echo "API_PULL=$API_PULL" >> "$GITHUB_OUTPUT"
          echo "WEB_FORCE_RESTART=$WEB_FORCE_RESTART" >> "$GITHUB_OUTPUT"
          echo "API_FORCE_RESTART=$API_FORCE_RESTART" >> "$GITHUB_OUTPUT"

          echo "Decisions:"
          echo "  web: tag=$WEB_TAG pullPolicy=$WEB_PULL restart=$WEB_FORCE_RESTART"
          echo "  api: tag=$API_TAG pullPolicy=$API_PULL restart=$API_FORCE_RESTART"

      - name: Helm upgrade (tag-based, independent web/api)
        shell: bash
        env:
          WEB_TAG: ${{ steps.tags.outputs.WEB_TAG }}
          API_TAG: ${{ steps.tags.outputs.API_TAG }}
          WEB_PULL: ${{ steps.mutate.outputs.WEB_PULL }}
          API_PULL: ${{ steps.mutate.outputs.API_PULL }}
        run: |
          set -euo pipefail
          echo "Deploying:"
          echo "  web: $WEB_IMAGE:$WEB_TAG (pullPolicy=$WEB_PULL)"
          echo "  api: $API_IMAGE:$API_TAG (pullPolicy=$API_PULL)"

          helm upgrade --install fullstack "./helm/chart" \
            --namespace "$NAMESPACE" --create-namespace \
            --dependency-update \
            --set-string web.image.repository="$WEB_IMAGE" \
            --set-string web.image.tag="$WEB_TAG" \
            --set-string web.image.pullPolicy="$WEB_PULL" \
            --set-string api.image.repository="$API_IMAGE" \
            --set-string api.image.tag="$API_TAG" \
            --set-string api.image.pullPolicy="$API_PULL"

      - name: Force rollout restart for mutable tags (if needed)
        if: ${{ steps.mutate.outputs.WEB_FORCE_RESTART == 'true' || steps.mutate.outputs.API_FORCE_RESTART == 'true' }}
        shell: bash
        run: |
          set -euo pipefail
          if [ "${{ steps.mutate.outputs.WEB_FORCE_RESTART }}" = "true" ]; then
            echo "Rolling out web (mutable tag)…"
            kubectl -n "$NAMESPACE" rollout restart deploy/web
          fi
          if [ "${{ steps.mutate.outputs.API_FORCE_RESTART }}" = "true" ]; then
            echo "Rolling out api (mutable tag)…"
            kubectl -n "$NAMESPACE" rollout restart deploy/api
          fi

      - name: Wait for rollouts
        shell: bash
        run: |
          set -euo pipefail
          kubectl -n "$NAMESPACE" rollout status deploy/web --timeout=300s || true
          kubectl -n "$NAMESPACE" rollout status deploy/api --timeout=300s || true

      - name: Show deployed images (after)
        shell: bash
        run: |
          set -euo pipefail
          echo "Web (after):"
          kubectl -n "$NAMESPACE" get deploy web -o jsonpath='{.spec.template.spec.containers[?(@.name=="web")].image}{"\n"}'
          echo "API (after):"
          kubectl -n "$NAMESPACE" get deploy api -o jsonpath='{.spec.template.spec.containers[?(@.name=="api")].image}{"\n"}'
          echo
          kubectl -n "$NAMESPACE" get pods -l app=web -o jsonpath='{range .items[*]}{.metadata.name}{"\t"}{.status.containerStatuses[?(@.name=="web")].image}{"\t"}{.status.containerStatuses[?(@.name=="web")].imageID}{"\n"}{end}' || true
          kubectl -n "$NAMESPACE" get pods -l app=api -o jsonpath='{range .items[*]}{.metadata.name}{"\t"}{.status.containerStatuses[?(@.name=="api")].image}{"\t"}{.status.containerStatuses[?(@.name=="api")].imageID}{"\n"}{end}' || true

      - name: Smoke test through Istio
        shell: bash
        run: |
          set -euo pipefail
          kubectl -n istio-system port-forward svc/istio-ingressgateway 8080:80 >/tmp/pf.log 2>&1 &
          PF_PID=$!
          sleep 3
          echo "== /api/health =="
          curl -fsS "http://localhost:8080/api/health" | tee /tmp/health.json
          echo "== /runtime-config.js (first line) =="
          curl -fsS "http://localhost:8080/runtime-config.js" | head -n 1 || true
          kill "$PF_PID" || true

