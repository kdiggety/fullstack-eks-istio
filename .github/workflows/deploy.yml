name: Deploy Local K8s (Umbrella Helm)

on:
  push:
    branches: [ main ]
    tags: [ 'v*.*.*' ]   # deploy on release tags too
  workflow_dispatch:
    inputs:
      tag:
        description: "Optional image tag override (e.g., v0.1.0)"
        required: false

concurrency:
  group: deploy-local
  cancel-in-progress: true

jobs:
  deploy:
    runs-on: [self-hosted, local-k8s]   # must match your runner's labels
    env:
      NAMESPACE: sample
    steps:
      - name: Checkout
        uses: actions/checkout@v4

      - name: Resolve image tag
        id: vars
        shell: bash
        run: |
          set -euo pipefail
          if [ -n "${{ github.event.inputs.tag || '' }}" ]; then
            TAG="${{ github.event.inputs.tag }}"
          elif [[ "${GITHUB_REF}" == refs/tags/v* ]]; then
            TAG="${GITHUB_REF_NAME}"     # deploy the release tag (e.g., v0.1.0)
          else
            TAG="${GITHUB_SHA::7}"       # fallback to short SHA
          fi
          printf 'TAG=%s\n' "$TAG" >> "$GITHUB_OUTPUT"
          echo "Using image tag: $TAG"

      - name: Show cluster context
        shell: bash
        run: |
          set -euo pipefail
          kubectl config current-context
          kubectl get nodes

      - name: Ensure images exist locally and load into cluster
        shell: bash
        run: |
          set -euo pipefail
          TAG="${{ steps.vars.outputs.TAG }}"

          # Build locally if missing
          if ! docker image inspect "sample-api:$TAG" >/dev/null 2>&1; then
            echo "sample-api:$TAG missing; building…"
            docker build -t "sample-api:$TAG" "${{ github.workspace }}/backend"
          fi
          if ! docker image inspect "sample-frontend:$TAG" >/dev/null 2>&1; then
            echo "sample-frontend:$TAG missing; building…"
            docker build -t "sample-frontend:$TAG" "${{ github.workspace }}/frontend"
          fi

          # Load into local cluster runtimes as needed
          if command -v minikube >/dev/null 2>&1; then
            echo "Detected minikube: loading images"
            minikube image load "sample-api:$TAG"
            minikube image load "sample-frontend:$TAG"
          elif command -v kind >/dev/null 2>&1; then
            echo "Detected kind: loading images"
            kind load docker-image "sample-api:$TAG"
            kind load docker-image "sample-frontend:$TAG"
          else
            echo "Assuming Docker Desktop Kubernetes: images already visible to cluster"
          fi

      - name: Ensure namespace & sidecar injection
        shell: bash
        run: |
          set -euo pipefail
          kubectl get ns "$NAMESPACE" || kubectl create ns "$NAMESPACE"
          kubectl label ns "$NAMESPACE" istio-injection=enabled --overwrite

      - name: Deploy via Helm (umbrella chart)
        shell: bash
        run: |
            set -euo pipefail
            TAG="${{ steps.vars.outputs.TAG }}"
            
            # Make sure we’re deploying the exact commit that contains your updated values.yaml
            git rev-parse --short HEAD
            sed -n '1,160p' helm/chart/values.yaml
            
            # Build/fetch subchart deps (fail fast if this breaks)
            helm dependency build "./helm/chart"
            
            # (Optional but great for catching missing values)
            echo "Rendering SealedSecrets to verify encryptedData exists..."
            helm template fullstack "./helm/chart" -n "$NAMESPACE" \
              | awk '/kind: SealedSecret/{flag=1} flag{print} /---/{flag=0}' \
              | sed -n '1,200p'
            
            # Upgrade/install with dependency update
            helm upgrade --install fullstack "./helm/chart" \
              --namespace "$NAMESPACE" --create-namespace \
              --dependency-update \
              --set api.image.repository=sample-api \
              --set api.image.tag="$TAG" \
              --set web.image.repository=sample-frontend \
              --set web.image.tag="$TAG"
            
            # Verify the release picked up the ciphertext and redis Secret exists
            echo "Checking SealedSecret and Secret in cluster..."
            kubectl -n "$NAMESPACE" get sealedsecret redis-auth -o jsonpath='{.spec.encryptedData.redis-password}{"\n"}'
            kubectl -n "$NAMESPACE" get secret redis-auth -o jsonpath='{.data.redis-password}{"\n"}' || true
            
            # Nudge redis to reload the secret if needed
            kubectl -n "$NAMESPACE" delete pod -l app.kubernetes.io/name=redis || true

      - name: Wait for rollouts
        shell: bash
        run: |
          set -euo pipefail
          # api & web Deployments are named after their release names in subcharts
          kubectl -n "$NAMESPACE" rollout status deploy/api --timeout=300s
          kubectl -n "$NAMESPACE" rollout status deploy/web --timeout=300s
          kubectl -n "$NAMESPACE" get pods -o wide

      - name: Smoke test through Istio
        shell: bash
        run: |
          set -euo pipefail
          kubectl -n istio-system get svc istio-ingressgateway

          kubectl -n istio-system port-forward svc/istio-ingressgateway 8080:80 >/tmp/pf.log 2>&1 &
          PF_PID=$!

          # wait for port-forward
          if command -v nc >/dev/null 2>&1; then
            for i in {1..20}; do nc -z localhost 8080 && break || sleep 0.5; done
          else
            sleep 3
          fi

          echo "== /api/health =="
          curl -fsS "http://localhost:8080/api/health" | tee /tmp/health.json

          echo "== / (frontend first 10 lines) =="
          curl -fsS "http://localhost:8080/" | head -n 10

          kill "$PF_PID" || true

      - name: If failed, dump diagnostics
        if: failure()
        shell: bash
        run: |
          echo "---- Pods ----"
          kubectl -n "$NAMESPACE" get pods -o wide || true
          echo "---- Events (tail) ----"
          kubectl -n "$NAMESPACE" get events --sort-by=.lastTimestamp | tail -n 100 || true
          echo "---- API logs ----"
          kubectl -n "$NAMESPACE" logs deploy/api -c api --tail=200 || true
          echo "---- WEB logs ----"
          kubectl -n "$NAMESPACE" logs deploy/web -c web --tail=200 || true
