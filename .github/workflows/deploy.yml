name: Deploy Local K8s (Umbrella Helm)

on:
  push:
    branches: [ main ]
    tags: [ 'v*.*.*' ]
  workflow_dispatch:
    inputs:
      tag:
        description: "Optional image tag override (e.g., v0.1.0 or a commit SHA)"
        required: false

concurrency:
  group: deploy-local
  cancel-in-progress: true

permissions:
  contents: read
  packages: read   # allows registry read if using GITHUB_TOKEN in this job (not required)

jobs:
  deploy:
    runs-on: [self-hosted, local-k8s]
    env:
      NAMESPACE: sample
      WEB_IMAGE: ghcr.io/${{ github.repository_owner }}/web
      API_IMAGE: ghcr.io/${{ github.repository_owner }}/api

    steps:
      - name: Checkout
        uses: actions/checkout@v4

      - name: Resolve base tag (prefer input → release tag → full SHA)
        id: vars
        shell: bash
        run: |
          set -euo pipefail
          if [ -n "${{ github.event.inputs.tag || '' }}" ]; then
            TAG="${{ github.event.inputs.tag }}"
          elif [[ "${GITHUB_REF}" == refs/tags/v* ]]; then
            TAG="${GITHUB_REF_NAME}"
          else
            TAG="${GITHUB_SHA}"
          fi
          echo "TAG=$TAG" >> "$GITHUB_OUTPUT"
          echo "Using base image tag: $TAG"

      - name: Show cluster context
        shell: bash
        run: |
          set -euo pipefail
          kubectl config current-context
          kubectl get nodes

      - name: Ensure namespace & sidecar injection
        shell: bash
        run: |
          set -euo pipefail
          kubectl get ns "$NAMESPACE" >/dev/null 2>&1 || kubectl create ns "$NAMESPACE"
          kubectl label ns "$NAMESPACE" istio-injection=enabled --overwrite

      # Optional: create/refresh imagePullSecret for private GHCR images and attach to default SA.
      # Provide repo/org secrets GHCR_USERNAME (your GitHub username) and GHCR_TOKEN (PAT with read:packages).
      - name: Ensure GHCR imagePullSecret and patch default SA
        shell: bash
        env:
          GHCR_USERNAME: ${{ secrets.GHCR_USERNAME }}
          GHCR_TOKEN: ${{ secrets.GHCR_TOKEN }}
          SECRET_NAME: ghcr-pull
        run: |
          set -euo pipefail
          if [ -n "${GHCR_USERNAME:-}" ] && [ -n "${GHCR_TOKEN:-}" ]; then
            kubectl -n "$NAMESPACE" delete secret "$SECRET_NAME" >/dev/null 2>&1 || true
            kubectl -n "$NAMESPACE" create secret docker-registry "$SECRET_NAME" \
              --docker-server=ghcr.io \
              --docker-username="$GHCR_USERNAME" \
              --docker-password="$GHCR_TOKEN"
            echo "Created/updated secret $SECRET_NAME in namespace $NAMESPACE"
          else
            echo "GHCR credentials not provided; skipping imagePullSecret creation."
          fi

          kubectl -n "$NAMESPACE" get sa default >/dev/null 2>&1 || kubectl -n "$NAMESPACE" create sa default
          kubectl -n "$NAMESPACE" patch serviceaccount default --type merge \
            -p "{\"imagePullSecrets\":[{\"name\":\"${SECRET_NAME}\"}]}" || true

          CURRENT="$(kubectl -n "$NAMESPACE" get sa default -o jsonpath='{.imagePullSecrets[*].name}' || true)"
          if [ -z "$CURRENT" ]; then
            kubectl -n "$NAMESPACE" patch serviceaccount default --type json \
              -p '[{"op":"add","path":"/imagePullSecrets","value":[{"name":"'"${SECRET_NAME}"'"}]}]'
          else
            kubectl -n "$NAMESPACE" patch serviceaccount default --type json \
              -p '[{"op":"replace","path":"/imagePullSecrets","value":[{"name":"'"${SECRET_NAME}"'"}]}]'
          fi
          echo "Patched default ServiceAccount with imagePullSecret ${SECRET_NAME}"

      - name: (Optional) GHCR login for tag checks
        if: ${{ secrets.GHCR_USERNAME != '' && secrets.GHCR_TOKEN != '' }}
        uses: docker/login-action@v3
        with:
          registry: ghcr.io
          username: ${{ secrets.GHCR_USERNAME }}
          password: ${{ secrets.GHCR_TOKEN }}

      - name: Resolve per-service tags (fall back to :dev if base tag not found)
        id: img
        shell: bash
        env:
          TAG: ${{ steps.vars.outputs.TAG }}
        run: |
          set -euo pipefail

          check_tag() {
            local ref="$1:$2"
            if docker buildx imagetools inspect "$ref" >/dev/null 2>&1; then
              echo "FOUND"
            else
              echo "MISSING"
            fi
          }

          WEB_TAG="$TAG"
          API_TAG="$TAG"

          if [ "$(check_tag "$WEB_IMAGE" "$WEB_TAG")" = "MISSING" ]; then
            echo "Web image tag '$WEB_TAG' not found; falling back to 'dev'."
            WEB_TAG="dev"
          fi
          if [ "$(check_tag "$API_IMAGE" "$API_TAG")" = "MISSING" ]; then
            echo "API image tag '$API_TAG' not found; falling back to 'dev'."
            API_TAG="dev"
          fi

          echo "WEB_TAG=$WEB_TAG" >> "$GITHUB_OUTPUT"
          echo "API_TAG=$API_TAG" >> "$GITHUB_OUTPUT"
          echo "Resolved tags → web: $WEB_TAG, api: $API_TAG"

      - name: Add helm repos
        shell: bash
        run: |
          set -euo pipefail
          helm repo add bitnami https://charts.bitnami.com/bitnami
          helm repo update

      - name: Build/fetch subchart deps
        shell: bash
        run: helm dependency build "./helm/chart"

      - name: Helm upgrade (use GHCR images + resolved per-service tags)
        shell: bash
        env:
          WEB_TAG: ${{ steps.img.outputs.WEB_TAG }}
          API_TAG: ${{ steps.img.outputs.API_TAG }}
        run: |
          set -euo pipefail

          echo "Rendering (dry-run) to sanity-check values..."
          helm upgrade --install fullstack "./helm/chart" -n "$NAMESPACE" \
            --dry-run --debug \
            --set web.image.repository="$WEB_IMAGE" \
            --set web.image.tag="$WEB_TAG" \
            --set api.image.repository="$API_IMAGE" \
            --set api.image.tag="$API_TAG" \
            >/dev/null

          echo "Applying release..."
          helm upgrade --install fullstack "./helm/chart" \
            --namespace "$NAMESPACE" --create-namespace \
            --dependency-update \
            --set web.image.repository="$WEB_IMAGE" \
            --set web.image.tag="$WEB_TAG" \
            --set api.image.repository="$API_IMAGE" \
            --set api.image.tag="$API_TAG"

      - name: Wait for rollouts
        shell: bash
        run: |
          set -euo pipefail
          kubectl -n "$NAMESPACE" rollout status deploy/api --timeout=300s
          kubectl -n "$NAMESPACE" rollout status deploy/web --timeout=300s
          kubectl -n "$NAMESPACE" get pods -o wide

      - name: Smoke test through Istio
        shell: bash
        run: |
          set -euo pipefail
          kubectl -n istio-system get svc istio-ingressgateway

          kubectl -n istio-system port-forward svc/istio-ingressgateway 8080:80 >/tmp/pf.log 2>&1 &
          PF_PID=$!

          if command -v nc >/dev/null 2>&1; then
            for i in {1..20}; do nc -z localhost 8080 && break || sleep 0.5; done
          else
            sleep 3
          fi

          echo "== /api/health =="
          curl -fsS "http://localhost:8080/api/health" | tee /tmp/health.json

          echo "== / (frontend first 10 lines) =="
          curl -fsS "http://localhost:8080/" | head -n 10

          kill "$PF_PID" || true

      - name: If failed, dump diagnostics
        if: failure()
        shell: bash
        run: |
          echo "---- Pods ----"
          kubectl -n "$NAMESPACE" get pods -o wide || true
          echo "---- Events (tail) ----"
          kubectl -n "$NAMESPACE" get events --sort-by=.lastTimestamp | tail -n 100 || true
          echo "---- API logs ----"
          kubectl -n "$NAMESPACE" logs deploy/api -c api --tail=200 || true
          echo "---- WEB logs ----"
          kubectl -n "$NAMESPACE" logs deploy/web -c web --tail=200 || true
